/*
 * usart_lib.c
 *
 *  Created on: Jul 24, 2024
 *      Author: bhadula.kishor
 */

#include "app_header.h"
#include "usart_lib.h"
#include "stm32f411xe.h"
#include <stdlib.h>

volatile USART_BUFFER usart1_buf; // Allocated statically
volatile USART_BUFFER usart2_buf; // Allocated statically
volatile USART_BUFFER usart6_buf; // Allocated statically

uint8_t USART_BUFFERSIZE = 20;


// It will initialize the dedicated peripheral depending on the passed USART peripheral from USART1 USART2 and USART6

void usartx_init(USART_TypeDef *usart){
	usart->CR1 |= (USART_CR1_TE | USART_CR1_RE);
	usart->CR1 |= USART_CR1_UE;
	reset_transmit_buffer(usart);
	reset_receive_buffer(usart);
}


// It will set the baud rate for the communication
uint16_t setDiv(uint32_t pCLK, uint32_t baud){
	return (uint16_t)((pCLK+(baud/2U))/baud);
}
void setBaudRate(USART_TypeDef *usart, uint32_t baud, uint32_t pClk){
	usart->BRR = setDiv(pClk, baud);
}



bool transmit_frame(USART_TypeDef *usart, char *frame, uint8_t frameLength){
	if(frameLength > USART_BUFFERSIZE){
		return false;
	}
	volatile USART_BUFFER *buffer = NULL;
	if(usart == USART1){
		buffer = &usart1_buf;
	}else if(usart == USART2){
		buffer = &usart2_buf;
	}else if(usart == USART6){
		buffer = &usart6_buf;
	}else{
		return false;
	}

	// Check if already buffer is occupied by some other transmission
	if(!buffer->isReadyToTransmit){
		return false;
	}

	volatile uint8_t index = 0;
	buffer->occupiedSize = frameLength;
	buffer->txIndex = 0;

	while(frameLength > 0){
		buffer->txBuffer[index] = *frame;
		frame++;
		index++;
		frameLength--;
	}

	// Finally enabling Transmission interrupt
	usart->CR1 |= USART_CR1_TXEIE;

	return true;
}


// Interrupt Handler

void usart_interrupt_commonHandler(USART_TypeDef *usart){
	volatile USART_BUFFER *buffer = NULL;
	if(usart == USART1){
		buffer = &usart1_buf;
	}else if(usart == USART2){
		buffer = &usart2_buf;
	}else if(usart == USART6){
		buffer = &usart6_buf;
	}else{
		return;
	}

	// Handling Transmission Interrupt

	if(usart->SR & USART_SR_TXE){
		if(buffer->txIndex < buffer->occupiedSize){
			usart->DR = buffer->txBuffer[buffer->txIndex];
			buffer->txIndex++;
			buffer->isReadyToTransmit = false;
		}else{
			buffer->isReadyToTransmit = true;
			usart->CR1 &= ~(USART_CR1_TXEIE);
		}
	}


	// Handling Reception of data
	if(usart->SR & USART_SR_RXNE){
		if(buffer->rxIndex < USART_BUFFERSIZE){
			buffer->rxBuffer[buffer->rxIndex] = usart->DR;
			buffer->rxIndex++;
			buffer->rxOccupiedSize++;
		}
		buffer->isNewFrame = false;  // To indicate that upcoming series of bytes belong to the same frame and not a new one.
	}else{
		reset_receive_buffer(usart);
	}
}

void reset_transmit_buffer(USART_TypeDef *usart){
	volatile USART_BUFFER *buffer = NULL;
	if(usart == USART1){
		buffer = &usart1_buf;
	}else if(usart == USART2){
		buffer = &usart2_buf;
	}else if(usart == USART6){
		buffer = &usart6_buf;
	}else{
		return;
	}

	buffer->txIndex = 0;
	buffer->isReadyToTransmit = true;
	buffer->occupiedSize = 0;
}

void reset_receive_buffer(USART_TypeDef *usart){
	volatile USART_BUFFER *buffer = NULL;
	if(usart == USART1){
		buffer = &usart1_buf;
	}else if(usart == USART2){
		buffer = &usart2_buf;
	}else if(usart == USART6){
		buffer = &usart6_buf;
	}else{
		return;
	}
	buffer->rxIndex = 0;
	buffer->rxOccupiedSize = 0;
	buffer->isNewFrame =  true;

}
void USART1_IRQHandler(void){
	usart_interrupt_commonHandler(USART1);
}

void USART2_IRQHandler(void){
	usart_interrupt_commonHandler(USART2);
}

void USART6_IRQHandler(void){
	usart_interrupt_commonHandler(USART6);
}
